This project solves the mazes in three different ways, by first converting the maze into a graph, and then applying one of the standard graph algorithms:
Depth-First-Search
Breadth-First-Search
Dijsktra's Algorithm (to find the path from "start" to "end" that uses edges with a minimal total cost). 
My mazes will always have a starting point at the upper left corner and an ending point at the lower right corner.My mazes have random weights (from 1 to 9) specified between any two adjacent junctures. These values can be thought of as the "cost" of traveling from one juncture to an adjacent one. The weights are used for running Dijkstra's algorithm. My mazes can be made with varying degrees of "density" from very sparse to "100% dense". The more dense the maze, the more walls it has. A very sparse maze has very few walls at all; instead it has a lot of open space so that there are many different paths leading from one juncture to another juncture that is far away. On the other end of the spectrum, a maze with "100% density" contains lots more walls and has the interesting property that there is always exactly one path from one juncture to any other juncture in the maze.
